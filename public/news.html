<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üì∞ News Feed</title>
  <style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #0f0f0f;
    color: #fff;
    padding: 20px;
    max-width: 1200px;
    margin: 0 auto;
  }
  h1 { 
    font-size: 28px; 
    margin-bottom: 8px;
    color: #fff;
  }
  .subtitle {
    color: #aaa;
    font-size: 14px;
    margin-bottom: 30px;
  }
  .sync-status {
    font-size: 12px;
    color: #666;
    margin-bottom: 10px;
  }
  .sync-status.synced { color: #4a4; }
  .sync-status.syncing { color: #aa4; }
  .sync-status.error { color: #a44; }
  .category { margin-bottom: 40px; }
  .category h2 { 
    font-size: 20px; 
    margin-bottom: 16px;
    color: #fff;
    border-bottom: 1px solid #333;
    padding-bottom: 8px;
  }
  .video-card {
    background: #1a1a1a;
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 20px;
    transition: opacity 0.3s, border 0.2s;
    position: relative;
  }
  .video-card.watched .video-header {
    opacity: 0.5;
  }
  .video-card.watched .new-badge {
    display: none;
  }
  .video-card.selected {
    border: 2px solid #4a9eff;
  }
  .video-card.watched .video-title::before {
    content: "‚úì ";
    color: #4a4;
  }
  .video-header {
    display: flex;
    gap: 16px;
    padding: 16px;
    cursor: pointer;
  }
  .video-header:hover {
    background: #252525;
  }
  .video-card.watched .video-header:hover {
    opacity: 1;
  }
  .select-checkbox {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 20px;
    height: 20px;
    cursor: pointer;
    z-index: 10;
    accent-color: #4a9eff;
  }
  .thumb-container {
    position: relative;
    flex-shrink: 0;
  }
  .thumb {
    width: 200px;
    height: 112px;
    border-radius: 8px;
    object-fit: cover;
    background: #333;
  }
  .new-badge {
    position: absolute;
    top: 6px;
    left: 6px;
    background: #ff0000;
    color: #fff;
    font-size: 11px;
    font-weight: 700;
    padding: 2px 6px;
    border-radius: 4px;
  }
  .duration {
    background: rgba(0,0,0,0.8);
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 12px;
    position: absolute;
    bottom: 6px;
    right: 6px;
  }
  .video-info {
    flex: 1;
    min-width: 0;
  }
  .creator-name {
    font-size: 12px;
    color: #888;
    margin-bottom: 4px;
  }
  .creator-name a {
    color: #aaa;
    text-decoration: none;
  }
  .creator-name a:hover {
    color: #fff;
    text-decoration: underline;
  }
  .video-title {
    font-size: 16px;
    font-weight: 500;
    color: #fff;
    line-height: 1.4;
    margin-bottom: 8px;
  }
  .video-meta {
    display: flex;
    gap: 12px;
    font-size: 13px;
    color: #888;
  }
  .video-date {
    color: #aaa;
  }
  .player-container {
    display: none;
    background: #000;
  }
  .player-container.active {
    display: block;
  }
  .player-container iframe {
    width: 100%;
    aspect-ratio: 16/9;
    border: none;
  }
  .controls {
    display: flex;
    gap: 12px;
    margin-bottom: 20px;
    flex-wrap: wrap;
    align-items: center;
  }
  .controls button {
    background: #333;
    color: #fff;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
  }
  .controls button:hover {
    background: #444;
  }
  .controls button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  .selection-count {
    font-size: 13px;
    color: #888;
  }
  .new-videos-banner {
    background: #1a3a1a;
    border: 1px solid #2a5a2a;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
    display: none;
  }
  .new-videos-banner.visible {
    display: block;
  }
  .new-videos-banner h3 {
    color: #6c6;
    margin-bottom: 12px;
    font-size: 16px;
  }
  .new-video-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #2a4a2a;
  }
  .new-video-item:last-child {
    border-bottom: none;
  }
  .new-video-item button {
    background: #4a4;
    color: #fff;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
  }
  .new-video-item button:hover {
    background: #5b5;
  }
  .updated {
    text-align: center;
    color: #555;
    font-size: 12px;
    margin-top: 40px;
    padding-top: 20px;
    border-top: 1px solid #222;
  }
  .last-refresh {
    color: #555;
    font-size: 12px;
    text-align: right;
    margin-bottom: 8px;
  }
  .stats-footer {
    display: flex;
    justify-content: flex-end;
    gap: 30px;
    margin-bottom: 20px;
    padding: 12px 20px;
    background: #1a1a1a;
    border-radius: 12px;
  }
  .stat-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .stat-label {
    color: #888;
    font-size: 13px;
  }
  .stat-value {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
  }
  #watched-duration { color: #f44; }
  #remaining-duration { color: #4a4; }
  .new-video-indicator {
    background: #1a2a1a;
    border-left: 3px solid #4a4;
    padding: 10px 16px;
    margin: -8px 0 12px 0;
    border-radius: 0 8px 8px 0;
    font-size: 13px;
    color: #ccc;
  }
  .indicator-badge {
    font-weight: 600;
    color: #6c6;
  }
  .indicator-duration {
    color: #888;
  }
  @media (max-width: 600px) {
    .video-header { flex-direction: column; }
    .thumb { width: 100%; height: auto; aspect-ratio: 16/9; }
  }
</style>
</head>
<body>
  <div style="margin-bottom:12px;display:flex;justify-content:space-between;align-items:center"><a href="https://youtube-playlists-alpha.vercel.app/" style="color:#4a9eff;text-decoration:none;font-size:14px">‚Üê Back to Home</a><a href="https://youtube-playlists-alpha.vercel.app/settings" style="color:#888;text-decoration:none;font-size:14px">‚öôÔ∏è Manage Channels</a></div>
  <h1>üì∞ News Feed</h1>
  <p class="subtitle">News and current events from trusted sources ‚Ä¢ Click to play</p>
  <div class="last-refresh" id="last-refresh">Checking...</div>
  <div id="sync-status" class="sync-status">Loading...</div>
  
  <!-- New video indicators appear inline below each creator's card -->

  <div class="stats-footer">
    <div class="stat-item">
      <span class="stat-label">Total on page:</span>
      <span class="stat-value" id="total-duration">--</span>
    </div>
    <div class="stat-item">
      <span class="stat-label">Watched:</span>
      <span class="stat-value" id="watched-duration">--</span>
    </div>
    <div class="stat-item">
      <span class="stat-label">Remaining:</span>
      <span class="stat-value" id="remaining-duration">--</span>
    </div>
  </div>
  
  <div class="controls">
    <button onclick="hideWatched()">Hide Watched</button>
    <button onclick="clearWatched()">Clear History</button>
    <button id="refresh-selected-btn" onclick="refreshSelected()" disabled>Refresh Selected</button>
    <span id="selection-count" class="selection-count"></span>
  </div>
  <div class="updated">Last updated: Feb 14, 2026, 12:00 AM PST</div>
  <script>
  const BLOB_URL = 'https://jsonblob.com/api/jsonBlob/019c547f-4dd8-779b-ba67-4d612b238762';
  let userData = { watched: {}, myVideos: {}, pendingNew: [] };
  let syncTimeout = null;
  let selectedVideos = new Set();
  
  // Get page type from URL or hostname
  const pageType = location.hostname.includes('entertainment') ? 'entertainment' :
                   location.hostname.includes('news') ? 'news' :
                   location.pathname.includes('entertainment') ? 'entertainment' : 'research';
  
  async function loadUserData() {
    setStatus('syncing', 'Loading...');
    try {
      const res = await fetch(BLOB_URL);
      const data = await res.json();
      userData = {
        watched: data.watched || {},
        myVideos: data.myVideos || {},
        pendingNew: data.pendingNew || []
      };
      
      // First visit: if no myVideos for this page, add all current videos
      if (!userData.myVideos[pageType] || Object.keys(userData.myVideos[pageType]).length === 0) {
        userData.myVideos[pageType] = {};
        document.querySelectorAll('.video-card').forEach(card => {
          const videoId = card.dataset.videoId;
          const creator = card.dataset.creator;
          userData.myVideos[pageType][videoId] = { 
            added: Date.now(),
            creator: creator
          };
        });
        await saveUserData();
      }
      
      updateUI();
      showPendingNewVideos();
      setStatus('synced', 'Synced ‚úì');
    } catch (e) {
      console.error('Cloud sync unavailable:', e);
      setStatus('error', 'Sync failed: ' + e.message);
      // Fall back to localStorage
      try {
        const local = localStorage.getItem('yt-userData');
        if (local) {
          userData = JSON.parse(local);
          updateUI();
          showPendingNewVideos();
          setStatus('error', 'Local mode (sync failed: ' + e.message + ')');
          return;
        }
      } catch {}
      // First visit with no sync - show all videos (no filtering)
      setStatus('error', 'First visit, no sync - showing all');
      userData.myVideos[pageType] = {};
      document.querySelectorAll('.video-card').forEach(card => {
        const videoId = card.dataset.videoId;
        const creator = card.dataset.creator;
        userData.myVideos[pageType][videoId] = { added: Date.now(), creator };
      });
      localStorage.setItem('yt-userData', JSON.stringify(userData));
      setStatus('synced', 'Local mode ‚úì');
    }
  }
  
  async function saveUserData() {
    setStatus('syncing', 'Saving...');
    // Always save to localStorage
    localStorage.setItem('yt-userData', JSON.stringify(userData));
    try {
      await fetch(BLOB_URL, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      setStatus('synced', 'Synced ‚úì');
    } catch (e) {
      console.error('Cloud sync unavailable:', e);
      setStatus('synced', 'Local mode ‚úì');
    }
  }
  
  function debouncedSave() {
    clearTimeout(syncTimeout);
    syncTimeout = setTimeout(saveUserData, 500);
  }
  
  function setStatus(cls, text) {
    const el = document.getElementById('sync-status');
    if (el) {
      el.className = 'sync-status ' + cls;
      el.textContent = text;
    }
  }
  
  function setWatched(videoId) {
    userData.watched[videoId] = Date.now();
    debouncedSave();
  }
  
  function isWatched(videoId) {
    return !!userData.watched[videoId];
  }
  
  function updateUI() {
    const userPageVideos = (userData.myVideos && userData.myVideos[pageType]) || {};
    const hasUserVideos = Object.keys(userPageVideos).length > 0;
    
    document.querySelectorAll('.video-card').forEach(card => {
      const videoId = card.dataset.videoId;
      
      // Hide videos not in user's list (unless first visit / no list yet)
      if (hasUserVideos && !userPageVideos[videoId]) {
        card.style.display = 'none';
        return;
      } else {
        card.style.display = '';
      }
      
      // Update watched state
      if (isWatched(videoId)) {
        card.classList.add('watched');
      } else {
        card.classList.remove('watched');
      }
      
      // Update selection state
      if (selectedVideos.has(videoId)) {
        card.classList.add('selected');
        card.querySelector('.select-checkbox').checked = true;
      } else {
        card.classList.remove('selected');
        card.querySelector('.select-checkbox').checked = false;
      }
    });
    
    // Hide empty categories
    document.querySelectorAll('.category').forEach(cat => {
      const visibleCards = cat.querySelectorAll('.video-card[style=""], .video-card:not([style])');
      const hasVisible = Array.from(cat.querySelectorAll('.video-card')).some(c => c.style.display !== 'none');
      cat.style.display = hasVisible ? '' : 'none';
    });
    
    updateSelectionCount();
  }
  
  function toggleSelect(videoId, checkbox, event) {
    event.stopPropagation();
    if (checkbox.checked) {
      selectedVideos.add(videoId);
    } else {
      selectedVideos.delete(videoId);
    }
    updateUI();
  }
  
  function updateSelectionCount() {
    const countEl = document.getElementById('selection-count');
    if (countEl) {
      const count = selectedVideos.size;
      countEl.textContent = count > 0 ? count + ' selected' : '';
    }
    
    const refreshBtn = document.getElementById('refresh-selected-btn');
    if (refreshBtn) {
      refreshBtn.disabled = selectedVideos.size === 0;
    }
  }
  
  function refreshSelected() {
    if (selectedVideos.size === 0) {
      alert('Select videos to refresh by clicking their checkboxes');
      return;
    }
    // For each selected video, check if there's a pending new video for that creator
    // If so, swap it in (replace the old video with the new one)
    let swapped = 0;
    selectedVideos.forEach(videoId => {
      const card = document.querySelector(`.video-card[data-video-id="${videoId}"]`);
      if (!card) return;
      const creator = card.dataset.creator;
      const pending = (userData.pendingNew || []).find(v => v.creator === creator && v.pageType === pageType);
      
      if (pending) {
        // Remove old video from myVideos
        if (userData.myVideos[pageType]) delete userData.myVideos[pageType][videoId];
        // Add new video to myVideos
        if (!userData.myVideos[pageType]) userData.myVideos[pageType] = {};
        userData.myVideos[pageType][pending.videoId] = { added: Date.now(), creator: pending.creator };
        // Remove from pending
        userData.pendingNew = userData.pendingNew.filter(v => v.videoId !== pending.videoId);
        // Update the card in-place
        swapCardContent(card, pending);
        swapped++;
      }
    });
    selectedVideos.clear();
    saveUserData().then(() => {
      updateUI();
      showNewVideoIndicators();
    });
    if (swapped > 0) {
      // Uncheck all
      document.querySelectorAll('.select-checkbox').forEach(cb => cb.checked = false);
    }
  }
  
  function swapCardContent(card, newVideo) {
    // Update card attributes
    card.dataset.videoId = newVideo.videoId;
    // Update thumbnail
    const thumb = card.querySelector('.thumb');
    if (thumb) thumb.src = newVideo.thumbnail || 'https://i.ytimg.com/vi/' + newVideo.videoId + '/hqdefault.jpg';
    // Update title
    const title = card.querySelector('.video-title');
    if (title) title.textContent = newVideo.title;
    // Update duration
    const dur = card.querySelector('.duration');
    if (dur) dur.textContent = newVideo.duration || '';
    // Update date
    const dateEl = card.querySelector('.video-date');
    if (dateEl) dateEl.textContent = newVideo.dateStr || '';
    // Update NEW badge
    let badge = card.querySelector('.new-badge');
    if (!badge) {
      badge = document.createElement('span');
      badge.className = 'new-badge';
      badge.textContent = 'NEW';
      card.querySelector('.thumb-container')?.appendChild(badge);
    }
    badge.style.display = '';
    // Update checkbox onclick
    const cb = card.querySelector('.select-checkbox');
    if (cb) cb.setAttribute('onclick', "toggleSelect('" + newVideo.videoId + "', this, event)");
    // Update header onclick
    const header = card.querySelector('.video-header');
    if (header) header.setAttribute('onclick', "togglePlayer(this.parentElement, '" + newVideo.videoId + "')");
    // Close any open player
    const player = card.querySelector('.player-container');
    if (player) { player.classList.remove('active'); player.innerHTML = ''; }
    // Remove watched state
    card.classList.remove('watched');
  }
  
  function showNewVideoIndicators() {
    // Remove old indicators
    document.querySelectorAll('.new-video-indicator').forEach(el => el.remove());
    
    const pending = (userData.pendingNew || []).filter(v => v.pageType === pageType);
    if (pending.length === 0) return;
    
    // For each pending video, find the card for that creator and add indicator below it
    pending.forEach(p => {
      // Find the card for this creator
      const cards = document.querySelectorAll(`.video-card[data-creator="${p.creator}"]`);
      const card = Array.from(cards).find(c => c.style.display !== 'none');
      if (!card) return;
      
      const currentVideoId = card.dataset.videoId;
      
      // If current video is watched, auto-swap
      if (isWatched(currentVideoId)) {
        // Remove old from myVideos, add new
        if (userData.myVideos[pageType]) delete userData.myVideos[pageType][currentVideoId];
        if (!userData.myVideos[pageType]) userData.myVideos[pageType] = {};
        userData.myVideos[pageType][p.videoId] = { added: Date.now(), creator: p.creator };
        userData.pendingNew = userData.pendingNew.filter(v => v.videoId !== p.videoId);
        swapCardContent(card, p);
        debouncedSave();
        return;
      }
      
      // Not watched ‚Äî show indicator below card
      const indicator = document.createElement('div');
      indicator.className = 'new-video-indicator';
      indicator.innerHTML = `<span class="indicator-badge">üÜï NEW</span> <strong>${p.creator}</strong>: ${p.title} ¬∑ <span class="indicator-duration">${p.duration || ''}</span>`;
      card.after(indicator);
    });
  }
  
  // Keep old function name for compatibility but redirect
  function showPendingNewVideos() { showNewVideoIndicators(); }
  
  let watchTimers = {};

  function togglePlayer(card, videoId) {
    const container = card.querySelector('.player-container');
    const isActive = container.classList.contains('active');
    
    // Close all other players and clear their timers
    document.querySelectorAll('.player-container.active').forEach(p => {
      p.classList.remove('active');
      p.innerHTML = '';
    });
    Object.keys(watchTimers).forEach(id => {
      if (id !== videoId) { clearTimeout(watchTimers[id]); delete watchTimers[id]; }
    });
    
    if (!isActive) {
      container.innerHTML = '<iframe src="https://www.youtube.com/embed/' + videoId + '?autoplay=1" allow="autoplay; encrypted-media" allowfullscreen></iframe>';
      container.classList.add('active');
      
      // Mark as watched after 30 seconds of viewing
      if (!isWatched(videoId)) {
        watchTimers[videoId] = setTimeout(() => {
          setWatched(videoId);
          card.classList.add('watched');
          updateUI();
          debouncedSave();
          delete watchTimers[videoId];
        }, 30000);
      }
    } else {
      // Closing player ‚Äî cancel timer
      if (watchTimers[videoId]) { clearTimeout(watchTimers[videoId]); delete watchTimers[videoId]; }
    }
  }
  
  async function clearWatched() {
    if (confirm('Clear all watched markers across all devices?')) {
      userData.watched = {};
      await saveUserData();
      updateUI();
    }
  }
  
  function hideWatched() {
    const hidden = document.body.classList.toggle('hide-watched');
    document.querySelectorAll('.video-card.watched').forEach(card => {
      card.style.display = hidden ? 'none' : 'block';
    });
  }
  
  // Stats functions
  function parseDuration(str) {
    if (!str) return 0;
    const parts = str.split(':').map(Number);
    if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
    if (parts.length === 2) return parts[0] * 60 + parts[1];
    return parts[0] || 0;
  }
  function formatDuration(seconds) {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    if (h > 0) return h + 'h ' + m + 'm';
    return m + 'm';
  }
  function updateStats() {
    let total = 0, watched = 0;
    document.querySelectorAll('.video-card').forEach(card => {
      const durEl = card.querySelector('.duration');
      if (!durEl) return;
      const dur = parseDuration(durEl.textContent.trim());
      total += dur;
      if (card.classList.contains('watched')) watched += dur;
    });
    document.getElementById('total-duration').textContent = formatDuration(total);
    document.getElementById('watched-duration').textContent = formatDuration(watched);
    document.getElementById('remaining-duration').textContent = formatDuration(total - watched);
  }
  const _origUpdateUI = updateUI;
  updateUI = function() { _origUpdateUI(); updateStats(); };

  // Last refresh indicator
  fetch('/last-refresh.json?' + Date.now())
    .then(r => r.json())
    .then(d => {
      const dt = new Date(d.lastRefresh);
      const now = new Date();
      const diffH = Math.floor((now - dt) / 3600000);
      const diffM = Math.floor(((now - dt) % 3600000) / 60000);
      let ago = diffH > 0 ? diffH + 'h ' + diffM + 'm ago' : diffM + 'm ago';
      document.getElementById('last-refresh').textContent = 'üîÑ Last checked for new content: ' + ago;
    })
    .catch(() => { document.getElementById('last-refresh').textContent = ''; });

  // Initialize on load
  document.addEventListener('DOMContentLoaded', () => { loadUserData(); updateStats(); });
</script>
</body>
</html>